import csv
from collections import defaultdict

CSV1 = "C:/Users/User/Downloads/combined_snap_data.csv"
CSV2 = "C:/Users/User/Downloads/csv2_fy2023_state_demographics.csv"
OUTPUT = "C:/Users/User/snap-dashboard/snap-state-data.js"

ABBR_TO_NAME = {
    "AL": "Alabama", "AK": "Alaska", "AZ": "Arizona", "AR": "Arkansas",
    "CA": "California", "CO": "Colorado", "CT": "Connecticut", "DE": "Delaware",
    "FL": "Florida", "GA": "Georgia", "HI": "Hawaii", "ID": "Idaho",
    "IL": "Illinois", "IN": "Indiana", "IA": "Iowa", "KS": "Kansas",
    "KY": "Kentucky", "LA": "Louisiana", "ME": "Maine", "MD": "Maryland",
    "MA": "Massachusetts", "MI": "Michigan", "MN": "Minnesota",
    "MS": "Mississippi", "MO": "Missouri", "MT": "Montana", "NE": "Nebraska",
    "NV": "Nevada", "NH": "New Hampshire", "NJ": "New Jersey",
    "NM": "New Mexico", "NY": "New York", "NC": "North Carolina",
    "ND": "North Dakota", "OH": "Ohio", "OK": "Oklahoma", "OR": "Oregon",
    "PA": "Pennsylvania", "RI": "Rhode Island", "SC": "South Carolina",
    "SD": "South Dakota", "TN": "Tennessee", "TX": "Texas", "UT": "Utah",
    "VT": "Vermont", "VA": "Virginia", "WA": "Washington",
    "WV": "West Virginia", "WI": "Wisconsin", "WY": "Wyoming",
    "DC": "District of Columbia",
}

NAME_TO_ABBR = {v: k for k, v in ABBR_TO_NAME.items()}
TARGET_MONTH = "Jan 2023"


def main():
    print("Reading " + CSV1)
    all_rows = []
    with open(CSV1, "r", encoding="utf-8") as f:
        reader = csv.DictReader(f)
        for row in reader:
            all_rows.append(row)
    print("  Total rows: " + str(len(all_rows)))

    grouped = defaultdict(list)
    for row in all_rows:
        grouped[(row["State_Abbr"], row["Month"])].append(row)

    states_in_data = sorted(set(r["State_Abbr"] for r in all_rows))
    months_in_data = sorted(set(r["Month"] for r in all_rows))
    print("  States: " + str(len(states_in_data)) + ", Months: " + str(months_in_data))

    state_results = {}

    for st in states_in_data:
        if st not in ABBR_TO_NAME:
            print("  Skipping " + st)
            continue

        if (st, TARGET_MONTH) in grouped:
            rows = grouped[(st, TARGET_MONTH)]
        else:
            available = [(m, grouped[(st, m)]) for m in months_in_data if (st, m) in grouped]
            if not available:
                continue
            rows = max(available, key=lambda x: len(x[1]))[1]
            print("  Note: " + st + " using " + rows[0]["Month"])

        county_rows = [r for r in rows if r["Data_Level"] == "County"]
        est_rows = [r for r in rows if r["Data_Level"] != "County"]

        persons = 0
        households = 0

        if county_rows:
            persons += sum(int(r["Total_Persons"]) for r in county_rows)
            households += sum(int(r["Total_Households"]) for r in county_rows)

        if est_rows:
            persons += int(est_rows[0]["PA_Persons"])
            households += int(est_rows[0]["Total_Households"])

        benefits = float(rows[0]["State_Total_Benefits"])

        if county_rows:
            rates = [float(r["Participation_Rate"]) for r in county_rows if float(r["Participation_Rate"]) > 0]
            participation_rate = sum(rates) / len(rates) if rates else 0.0
        elif est_rows:
            participation_rate = float(est_rows[0]["Participation_Rate"])
        else:
            participation_rate = 0.0

        state_results[st] = {
            "name": ABBR_TO_NAME[st],
            "persons": persons,
            "households": households,
            "benefits": benefits,
            "participationRate": round(participation_rate, 1),
        }

    # Read demographics CSV
    print("")
    print("Reading " + CSV2)
    demographics = {}
    with open(CSV2, "r", encoding="utf-8") as f:
        reader = csv.DictReader(f)
        for row in reader:
            state_name = row["State"].strip()
            abbr = NAME_TO_ABBR.get(state_name)
            if abbr:
                demographics[abbr] = row
            else:
                print("  WARNING: unmapped state: " + state_name)
    print("  Demographics loaded for " + str(len(demographics)) + " states")

    for abbr in sorted(ABBR_TO_NAME.keys()):
        if abbr not in state_results:
            print("  WARNING: " + abbr + " missing from SNAP data")

    # Generate JS output
    print("")
    print("Generating " + OUTPUT)
    js_lines = []
    js_lines.append("/* State-level SNAP data (FY2023) -- auto-generated by gen_state_data.py */")
    js_lines.append("// eslint-disable-next-line no-unused-vars")
    js_lines.append("const SNAP_STATE_DATA = {")

    for abbr in sorted(state_results.keys()):
        d = state_results[abbr]
        benefits_int = int(round(d["benefits"]))
        dq = chr(34)
        entry = "  " + abbr + ": { name: " + dq + d["name"] + dq + ", persons: " + str(d["persons"]) + ", households: " + str(d["households"]) + ", benefits: " + str(benefits_int) + ", participationRate: " + str(d["participationRate"]) + " },"
        js_lines.append(entry)

    js_lines.append("};")
    js_lines.append("")
    nl = chr(10)
    with open(OUTPUT, "w", encoding="utf-8") as f:
        f.write(nl.join(js_lines))
    print("  Written " + str(len(state_results)) + " states")

    # Summary
    sep = "=" * 82
    print("")
    print(sep)
    print("SUMMARY -- All states sorted by persons (descending)")
    print(sep)
    hdr = "{:>4}  {:>2}  {:<24}  {:>12}  {:>12}  {:>16}  {:>6}"
    print(hdr.format("Rank", "St", "State Name", "Persons", "Households", "Benefits", "PR%"))
    print("-" * 82)

    sorted_states = sorted(state_results.items(), key=lambda x: x[1]["persons"], reverse=True)
    for i, (abbr, d) in enumerate(sorted_states, 1):
        print(hdr.format(i, abbr, d["name"],
                         "{:,}".format(d["persons"]),
                         "{:,}".format(d["households"]),
                         "{:,.0f}".format(d["benefits"]),
                         "{:.1f}".format(d["participationRate"])))

    # Validation
    print("")
    print(sep)
    print("VALIDATION CHECKS")
    print(sep)
    expected_ranges = {
        "CA": (3000000, 6000000), "TX": (3000000, 5000000),
        "FL": (2500000, 4500000), "NY": (2000000, 4000000),
        "IL": (1500000, 3000000), "PA": (1500000, 2500000),
        "OH": (1000000, 2000000), "GA": (1000000, 2500000),
    }
    warn_list = []
    for abbr, (lo, hi) in expected_ranges.items():
        if abbr in state_results:
            actual = state_results[abbr]["persons"]
            if actual < lo:
                warn_list.append("  WARNING: " + abbr + " persons = " + "{:,}".format(actual) + " -- expected ~" + "{:,}".format(lo) + "-" + "{:,}".format(hi))
            elif actual > hi:
                warn_list.append("  NOTE: " + abbr + " persons = " + "{:,}".format(actual) + " -- higher than expected")
            else:
                print("  OK: " + abbr + " persons = " + "{:,}".format(actual) + " (expected " + "{:,}".format(lo) + "-" + "{:,}".format(hi) + ")")
        else:
            warn_list.append("  WARNING: " + abbr + " not in results!")

    if warn_list:
        print("")
        for w in warn_list:
            print(w)
        print("")
        print("  Note: Some states only have State Estimated data with PA_Persons")
        print("  (a subset) since county-level Total_Persons is not reported.")
        print("  Affected: CT, ID, MA, ME, NE, NH, NY, OR, VT, WA, WY")

    print("")
    print("Done.")


if __name__ == "__main__":
    main()

